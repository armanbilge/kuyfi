package kuyfi

import shapeless._
import scalaz.effect._

object TZDBCodeGenerator {
  import TZDB._
  import treehugger.forest._
  import treehuggerDSL._

  private val autoGeneratedCommend = "Auto-generated code from TZDB definitions, don't edit"

  // Typeclass of code generator
  trait TreeGenerator[A] {
    def generateTree(a: A): Tree
  }

  implicit class TreeGeneratorOps[A](val a: A) extends AnyVal {
    def toTree(implicit t: TreeGenerator[A]): Tree = t.generateTree(a)
  }

  object TreeGenerator {
    // "Summoner" method
    def apply[A](implicit enc: TreeGenerator[A]): TreeGenerator[A] = enc

    // "Constructor" method
    def instance[A](func: A => Tree): TreeGenerator[A] =
      new TreeGenerator[A] {
        def generateTree(value: A): Tree =
          func(value)
    }

    // Globally visible type class instances
    implicit def intInstance: TreeGenerator[Int] = instance(LIT.apply)
    implicit def stringInstance: TreeGenerator[String] = instance(LIT.apply)

    // Encoders for products
    implicit def cnilInstance: TreeGenerator[CNil] = instance(_ => throw new Exception("Cannot happen"))
    implicit def coproductInstance[H, T <: Coproduct](
      implicit
      hInstance: Lazy[TreeGenerator[H]], // wrap in Lazy
      tInstance: TreeGenerator[T]
    ): TreeGenerator[H :+: T] = instance {
      case Inl(h) => hInstance.value.generateTree(h)
      case Inr(t) => tInstance.generateTree(t)
    }

    implicit val zoneInstance: TreeGenerator[Zone] =
      instance(z => LIT(z.name))

    implicit val linkInstance: TreeGenerator[Link] =
      instance(l => TUPLE(l.to.toTree, l.from.toTree))

    implicit val zoneListInstance: TreeGenerator[List[Zone]] =
      instance( z =>
        LAZYVAL("allZones", "List[String]") := LIST(z.map(_.toTree))
      )

    implicit val linkInstances: TreeGenerator[List[Link]] =
      instance( l =>
        LAZYVAL("zoneLinks", "Map[String, String]") := MAKE_MAP(l.map(_.toTree): _*)
      )
  }

  // Go over the links and remove links whose source is unknown
  def cleanLinks(rows: List[Row]): List[Row] ={
    val zoneNames = rows.flatMap(_.select[Zone]).map(_.name)
    rows.filter {
      case r if r.select[Link].isDefined => r.select[Link].exists(l => zoneNames.contains(l.from))
      case _                             => true
    }
  }

  def exportAll(dir: java.io.File, to: java.io.File): IO[Unit] = {
    import better.files._
    for {
      rows      <- TZDBParser.parseAll(File(dir.toURI))
      cleanrows <- IO(cleanLinks(rows))
      tree      <- IO(exportAll("org.threeten.bp", cleanrows))
      _         <- IO(File(to.toURI).write(treeToString(tree)))
    } yield ()
  }

  def exportAll(zonePackage: String, rows: List[Row]): Tree = {
    BLOCK (
      List(IMPORT(s"$zonePackage._"),
      OBJECTDEF("tzdb") := BLOCK(rows.flatMap(_.select[Zone]).toTree, rows.flatMap(_.select[Link]).toTree))
    ) inPackage "tzdb" withComment autoGeneratedCommend
  }
}
