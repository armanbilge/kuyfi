package kuyfi

import shapeless._

import scalaz.effect._
import TZDB._
import treehugger.forest._
import definitions._
import treehuggerDSL._
import java.time.{DayOfWeek, ZoneOffset, LocalDateTime, LocalTime, Month}
import java.time.zone.ZoneOffsetTransitionRule
import java.time.zone.ZoneOffsetTransitionRule.TimeDefinition

object TZDBCodeGenerator {

  private val autoGeneratedCommend = "Auto-generated code from TZDB definitions, don't edit"

  val zoneOffsetSym: Symbol = getModule("ZoneOffset")
  val zoneOffsetTransitionSym: Symbol = getModule("ZoneOffsetTransition")
  val zoneOffsetTransitionRuleSym: Symbol = getModule("ZoneOffsetTransitionRule")
  val zoneRulesSym: Symbol = getModule("ZoneRules")
  val localDateTimeSym: Symbol = getModule("LocalDateTime")
  val localTimeSym: Symbol = getModule("LocalTime")

  // Typeclass of code generator
  trait TreeGenerator[A] {
    def generateTree(a: A): Tree
  }

  implicit class TreeGeneratorOps[A](val a: A) extends AnyVal {
    def toTree(implicit t: TreeGenerator[A]): Tree = t.generateTree(a)
  }

  object TreeGenerator {
    // "Summoner" method
    def apply[A](implicit enc: TreeGenerator[A]): TreeGenerator[A] = enc

    // "Constructor" method
    def instance[A](func: A => Tree): TreeGenerator[A] =
      new TreeGenerator[A] {
        def generateTree(value: A): Tree =
          func(value)
    }

    // Globally visible type class instances
    implicit def intInstance: TreeGenerator[Int] = instance(LIT.apply)
    implicit def stringInstance: TreeGenerator[String] = instance(LIT.apply)

    // Encoders for products
    implicit def cnilInstance: TreeGenerator[CNil] = instance(_ => throw new Exception("Cannot happen"))
    implicit def coproductInstance[H, T <: Coproduct](
      implicit
      hInstance: Lazy[TreeGenerator[H]], // wrap in Lazy
      tInstance: TreeGenerator[T]
    ): TreeGenerator[H :+: T] = instance {
      case Inl(h) => hInstance.value.generateTree(h)
      case Inr(t) => tInstance.generateTree(t)
    }

    implicit val zoneInstance: TreeGenerator[Zone] =
      instance(z => {
        // Fixed zone offset
        if (z.transitions.length == 1) {
          val at = z.transitions.head.offset
          val offset = (zoneOffsetSym DOT "ofHoursMinutesSeconds")(LIT(at.h), LIT(at.m), LIT(at.s))
          val rule = (zoneRulesSym DOT "of")(offset)
          TUPLE(LIT(z.name), rule)
        } else {
          val at = z.transitions.head.offset
          val offset = (zoneOffsetSym DOT "ofHoursMinutesSeconds")(LIT(at.h), LIT(at.m), LIT(at.s))
          val rule = (zoneRulesSym DOT "of")(offset)
          TUPLE(LIT(z.name), rule)
        }
      })

    implicit val linkInstance: TreeGenerator[Link] =
      instance(l => TUPLE(l.to.toTree, l.from.toTree))

    implicit val zoneListInstance: TreeGenerator[List[Zone]] =
      instance( z =>
        LAZYVAL("allZones", "Map[String, ZoneRules]") := MAKE_MAP(z.map(_.toTree))
      )

    implicit val linkInstances: TreeGenerator[List[Link]] =
      instance( l =>
        LAZYVAL("zoneLinks", "Map[String, String]") := MAKE_MAP(l.map(_.toTree): _*)
      )

    implicit val zoneOffsetInstance: TreeGenerator[ZoneOffset] =
      instance( l =>
        (zoneOffsetSym DOT "ofTotalSeconds")(LIT(l.getTotalSeconds))
      )

    implicit val dayOfWeekInstance: TreeGenerator[DayOfWeek] =
      instance(l => REF(s"DayOfWeek.${l.toString}"))

    implicit val timeDefinitionInstance: TreeGenerator[TimeDefinition] =
      instance(l => REF(s"TimeDefinition.${l.toString}"))

    implicit val monthInstance: TreeGenerator[Month] =
      instance(l => REF(s"Month.${l.toString}"))

    implicit val localDateTimeInstance: TreeGenerator[LocalDateTime] =
      instance( l =>
        (localDateTimeSym DOT "of")(LIT(l.getYear), LIT(l.getMonthValue), LIT(l.getDayOfMonth), LIT(l.getHour), LIT(l.getMinute), LIT(l.getSecond), LIT(l.getNano))
      )

    implicit val localTimeInstance: TreeGenerator[LocalTime] =
      instance( l =>
        (localTimeSym DOT "of")(LIT(l.getHour), LIT(l.getMinute), LIT(l.getSecond), LIT(l.getNano))
      )

    implicit val ZoneOffsetTransitionParamsInstance: TreeGenerator[ZoneOffsetTransitionParams] =
      instance( l =>
        (zoneOffsetTransitionSym DOT "of")(l.transition.toTree, l.offsetBefore.toTree, l.offsetAfter.toTree)
      )

    implicit val ZoneOffsetTransitionRuleInstance: TreeGenerator[ZoneOffsetTransitionRule] =
      instance( l =>
        (zoneOffsetTransitionRuleSym DOT "of")(l.getMonth.toTree, LIT(l.getDayOfMonthIndicator), l.getDayOfWeek.toTree, l.getLocalTime.toTree, LIT(l.isMidnightEndOfDay), l.getTimeDefinition.toTree, l.getStandardOffset.toTree, l.getOffsetBefore.toTree, l.getOffsetAfter.toTree)
      )

    implicit val zoneRules: TreeGenerator[ZoneRulesParams] =
      instance( l =>
        BLOCK(List(
          VAL("bso", "ZoneOffset") := l.baseStandardOffset.toTree,
          VAL("bwo", "ZoneOffset") := l.baseWallOffset.toTree,
          VAL("standardTransitions", "List[ZoneOffsetTransitionRule]") := LIST(l.standardOffsetTransitionList.map(_.toTree)),
          VAL("transitionList", "List[ZoneOffsetTransitionRule]") := LIST(l.transitionList.map(_.toTree))
        ))
      )
  }

  // Go over the links and remove links whose source is unknown
  def cleanLinks(rows: List[Row]): List[Row] ={
    val zoneNames = rows.flatMap(_.select[Zone]).map(_.name)
    rows.filter {
      case r if r.select[Link].isDefined => r.select[Link].exists(l => zoneNames.contains(l.from))
      case _                             => true
    }
  }

  def exportTzdb(tzdbPackage: String, importsPackage: String, rows: List[Row]): Tree = {
    BLOCK (
      List(
        IMPORT(s"$importsPackage._"),
        IMPORT(s"$importsPackage.zone._"),
        OBJECTDEF("tzdb") := BLOCK(rows.flatMap(_.select[Zone]).toTree, rows.flatMap(_.select[Link]).toTree))
    ) inPackage tzdbPackage withComment autoGeneratedCommend
  }

  def exportAll(dir: java.io.File, to: java.io.File, packageName: String, importsPackage: String): IO[Unit] = {
    import better.files._
    for {
      rows      <- TZDBParser.parseAll(File(dir.toURI))
      cleanrows <- IO(cleanLinks(rows))
      tree      <- IO(exportTzdb(packageName, importsPackage, cleanrows))
      _         <- IO(File(to.toURI).write(treeToString(tree)))
    } yield ()
  }

}
