package kuyfi

import shapeless._

import scalaz.effect._
import TZDB._
import treehugger.forest._
import definitions._
import treehuggerDSL._
import java.time.{DayOfWeek, ZoneOffset, LocalDateTime, LocalDate, LocalTime, Month}
import java.time.zone.ZoneOffsetTransitionRule
import java.time.zone.ZoneOffsetTransitionRule.TimeDefinition

object TZDBCodeGenerator {

  private val autoGeneratedCommend = "Auto-generated code from TZDB definitions, don't edit"

  val zoneOffsetSym: Symbol = getModule("ZoneOffset")
  val zoneOffsetTransitionSym: Symbol = getModule("ZoneOffsetTransition")
  val zoneOffsetTransitionRuleSym: Symbol = getModule("ZoneOffsetTransitionRule")
  val zoneRulesSym: Symbol = getModule("ZoneRules")
  val localDateTimeSym: Symbol = getModule("LocalDateTime")
  val localTimeSym: Symbol = getModule("LocalTime")
  //val LDT: Symbol

  // Typeclass of code generator
  trait TreeGenerator[A] {
    def generateTree(a: A): Tree
  }

  implicit class TreeGeneratorOps[A](val a: A) extends AnyVal {
    def toTree(implicit t: TreeGenerator[A]): Tree = t.generateTree(a)
  }

  object TreeGenerator {
    // "Summoner" method
    def apply[A](implicit enc: TreeGenerator[A]): TreeGenerator[A] = enc

    // "Constructor" method
    def instance[A](func: A => Tree): TreeGenerator[A] =
      new TreeGenerator[A] {
        def generateTree(value: A): Tree =
          func(value)
    }

    // Globally visible type class instances
    implicit def intInstance: TreeGenerator[Int] = instance(LIT.apply)
    implicit def stringInstance: TreeGenerator[String] = instance(LIT.apply)

    // Encoders for products
    implicit def cnilInstance: TreeGenerator[CNil] = instance(_ => throw new Exception("Cannot happen"))
    implicit def coproductInstance[H, T <: Coproduct](
      implicit
      hInstance: Lazy[TreeGenerator[H]], // wrap in Lazy
      tInstance: TreeGenerator[T]
    ): TreeGenerator[H :+: T] = instance {
      case Inl(h) => hInstance.value.generateTree(h)
      case Inr(t) => tInstance.generateTree(t)
    }
  }

  object PureTreeGenerator {
    implicit val zoneInstance: TreeGenerator[Zone] =
      TreeGenerator.instance(z =>
        TUPLE(LIT(z.name), REF(s"rules.${z.scalaSafeName}"))
      )

    implicit val linkInstance: TreeGenerator[Link] =
      TreeGenerator.instance(l => TUPLE(l.to.toTree, l.from.toTree))

    implicit val zoneListInstance: TreeGenerator[List[Zone]] =
      TreeGenerator.instance( z =>
        LAZYVAL("allZones", "Map[String, ZoneRules]") := MAKE_MAP(z.map(_.toTree))
      )

    implicit val linkInstances: TreeGenerator[List[Link]] =
      TreeGenerator.instance( l =>
        LAZYVAL("zoneLinks", "Map[String, String]") := MAKE_MAP(l.map(_.toTree): _*)
      )

    implicit val zoneOffsetInstance: TreeGenerator[ZoneOffset] =
      TreeGenerator.instance( l =>
        (zoneOffsetSym DOT "ofTotalSeconds")(LIT(l.getTotalSeconds))
      )

    implicit val dayOfWeekInstance: TreeGenerator[DayOfWeek] =
      TreeGenerator.instance(l => REF(s"DayOfWeek.${l.toString}"))

    implicit val timeDefinitionInstance: TreeGenerator[TimeDefinition] =
      TreeGenerator.instance(l => REF(s"ZoneOffsetTransitionRule.TimeDefinition.${l.toString}"))

    implicit val monthInstance: TreeGenerator[Month] =
      TreeGenerator.instance(l => REF(s"Month.${l.toString}"))

    implicit val localDateTimeInstance: TreeGenerator[LocalDateTime] =
      TreeGenerator.instance( l =>
        (localDateTimeSym DOT "of")(LIT(l.getYear), LIT(l.getMonthValue), LIT(l.getDayOfMonth), LIT(l.getHour), LIT(l.getMinute), LIT(l.getSecond), LIT(l.getNano))
      )

    implicit val localTimeInstance: TreeGenerator[LocalTime] =
      TreeGenerator.instance( l =>
        (localTimeSym DOT "of")(LIT(l.getHour), LIT(l.getMinute), LIT(l.getSecond), LIT(l.getNano))
      )

    implicit val ZoneOffsetTransitionParamsInstance: TreeGenerator[ZoneOffsetTransitionParams] =
      TreeGenerator.instance( l =>
        (zoneOffsetTransitionSym DOT "of")(l.transition.toTree, l.offsetBefore.toTree, l.offsetAfter.toTree)
      )

    implicit val ZoneOffsetTransitionRuleInstance: TreeGenerator[ZoneOffsetTransitionRule] =
      TreeGenerator.instance { l =>
        val dayOfWeek = Option(l.getDayOfWeek).map(_.toTree).getOrElse(NULL)
        (zoneOffsetTransitionRuleSym DOT "of")(l.getMonth.toTree, LIT(l.getDayOfMonthIndicator), dayOfWeek, l.getLocalTime.toTree, LIT(l.isMidnightEndOfDay), l.getTimeDefinition.toTree, l.getStandardOffset.toTree, l.getOffsetBefore.toTree, l.getOffsetAfter.toTree)
      }

    implicit val zoneAndRules: TreeGenerator[Map[Zone, ZoneRulesParams]] =
      TreeGenerator.instance { zones => BLOCK(zones.map {
        case (z, r) =>
          LAZYVAL(z.scalaSafeName, zoneRulesSym) := {
            // Fixed zone offset
            if (z.transitions.length == 1) {
              val at = z.transitions.head.offset
              val offset = (zoneOffsetSym DOT "ofHoursMinutesSeconds")(LIT(at.h), LIT(at.m), LIT(at.s))
              (zoneRulesSym DOT "of")(offset)
            } else {
              r.toTree
            }
          }
        })
      }

    implicit val zoneRules: TreeGenerator[ZoneRulesParams] =
      TreeGenerator.instance( l =>
        BLOCK(List(
          VAL("bso", "ZoneOffset") := l.baseStandardOffset.toTree,
          VAL("bwo", "ZoneOffset") := l.baseWallOffset.toTree,
          VAL("standardTransitions", "List[ZoneOffsetTransition]") := LIST(l.standardOffsetTransitionList.map(_.toTree)),
          VAL("transitionList", "List[ZoneOffsetTransition]") := LIST(l.transitionList.map(_.toTree)),
          VAL("lastRules", "List[ZoneOffsetTransitionRule]") := LIST(l.lastRules.map(_.toTree)),
          (zoneRulesSym DOT "of")(REF("bso"), REF("bwo"), REF("standardTransitions") POSTFIX("asJava"), REF("transitionList") POSTFIX("asJava"), REF("lastRules") POSTFIX("asJava"))
        ))
      )
  }

  object OptimizedTreeGenerator {
    implicit val zoneInstance: TreeGenerator[Zone] =
      TreeGenerator.instance(z =>
        TUPLE(LIT(z.name), REF(s"rules.${z.scalaSafeName}"))
      )

    implicit val linkInstance: TreeGenerator[Link] =
      TreeGenerator.instance(l => TUPLE(l.to.toTree, l.from.toTree))

    implicit val zoneListInstance: TreeGenerator[List[Zone]] =
      TreeGenerator.instance( z =>
        LAZYVAL("allZones", TYPE_MAP(StringClass, TYPE_REF("ZRO"))) := MAKE_MAP(z.map(_.toTree))
      )

    implicit val linkInstances: TreeGenerator[List[Link]] =
      TreeGenerator.instance( l =>
        LAZYVAL("zoneLinks", TYPE_MAP(StringClass, StringClass)) := MAKE_MAP(l.map(_.toTree): _*)
      )

    implicit val zoneOffsetInstance: TreeGenerator[ZoneOffset] =
      TreeGenerator.instance( l =>
        LIT(l.getTotalSeconds)
      )

    implicit val dayOfWeekInstance: TreeGenerator[DayOfWeek] =
      TreeGenerator.instance(l => LIT(l.getValue))

    implicit val timeDefinitionInstance: TreeGenerator[TimeDefinition] =
      TreeGenerator.instance(l => LIT(l.ordinal))

    implicit val monthInstance: TreeGenerator[Month] =
      TreeGenerator.instance(l => LIT(l.getValue))

    implicit val localDateTimeInstance: TreeGenerator[LocalDateTime] =
      TreeGenerator.instance( l =>
        TUPLE(l.toLocalDate.toTree, l.toLocalTime.toTree)
      )

    implicit val localTimeInstance: TreeGenerator[LocalTime] =
      TreeGenerator.instance( l =>
        LIT(l.toSecondOfDay)
      )

    implicit val localDateInstance: TreeGenerator[LocalDate] =
      TreeGenerator.instance( l =>
        TUPLE(LIT(l.getYear), LIT(l.getDayOfYear))
      )

    implicit val ZoneOffsetTransitionParamsInstance: TreeGenerator[ZoneOffsetTransitionParams] =
      TreeGenerator.instance( l =>
        TUPLE(l.transition.toTree, l.offsetBefore.toTree, l.offsetAfter.toTree)
      )

    implicit val ZoneOffsetTransitionRuleInstance: TreeGenerator[ZoneOffsetTransitionRule] =
      TreeGenerator.instance { l =>
        val dayOfWeek = Option(l.getDayOfWeek).fold(NONE)(x => SOME(x.toTree))
        TUPLE(l.getMonth.toTree, LIT(l.getDayOfMonthIndicator), dayOfWeek, l.getLocalTime.toTree, LIT(l.isMidnightEndOfDay), l.getTimeDefinition.toTree, l.getStandardOffset.toTree, l.getOffsetBefore.toTree, l.getOffsetAfter.toTree)
      }

    implicit val zoneAndRules: TreeGenerator[Map[Zone, ZoneRulesParams]] =
      TreeGenerator.instance { zones => BLOCK(zones.map {
        case (z, r) =>
          LAZYVAL(z.scalaSafeName, TYPE_REF("ZRO")) := {
            // Fixed zone offset
            if (z.transitions.length == 1) {
              val at = z.transitions.head.offset
              RIGHT(at.toZoneOffset.toTree)
            } else {
              LEFT(r.toTree)
            }
          }
        })
      }

    implicit val zoneRules: TreeGenerator[ZoneRulesParams] =
      TreeGenerator.instance( l =>
        BLOCK(List(
          VAL("bso", IntClass) := l.baseStandardOffset.toTree,
          VAL("bwo", IntClass) := l.baseWallOffset.toTree,
          VAL("standardTransitions", TYPE_LIST(TYPE_REF("ZOT"))) := LIST(l.standardOffsetTransitionList.map(_.toTree)),
          VAL("transitionList", TYPE_LIST(TYPE_REF("ZOT"))) := LIST(l.transitionList.map(_.toTree)),
          VAL("lastRules", TYPE_LIST(TYPE_REF("ZOR"))) := LIST(l.lastRules.map(_.toTree)),
          TUPLE(REF("bso"), REF("bwo"), REF("standardTransitions"), REF("transitionList"), REF("lastRules"))
        ))
      )
  }

  // Go over the links and remove links whose source is unknown
  def cleanLinks(rows: List[Row]): List[Row] ={
    val zoneNames = rows.flatMap(_.select[Zone]).map(_.name)
    rows.filter {
      case r if r.select[Link].isDefined => r.select[Link].exists(l => zoneNames.contains(l.from))
      case _                             => true
    }
  }

  def exportTzdb(tzdbPackage: String, importsPackage: String, rows: List[Row])
    (implicit genParams: TreeGenerator[Map[Zone, ZoneRulesParams]], genZones: TreeGenerator[List[Zone]], genLinks: TreeGenerator[List[Link]]): Tree = {
    val rules = ZoneRulesBuilder.calculateTransitionParams(rows)

    val zoneProviderSym = getModule("ZoneRulesProvider")
    val register = (zoneProviderSym DOT "registerProvider")(NULL)

    val aliases = List(
      TYPEVAR("LD") := TYPE_TUPLE(IntClass, IntClass),
      TYPEVAR("LT") := TYPE_REF(IntClass),
      TYPEVAR("LDT") := TYPE_TUPLE(TYPE_REF("LD"), TYPE_REF("LT")),
      TYPEVAR("ZOT") := TYPE_TUPLE(TYPE_REF("LDT"): Type, IntClass, IntClass),
      TYPEVAR("ZOR") := TYPE_TUPLE(IntClass, IntClass, TYPE_OPTION(IntClass), TYPE_REF("LT"): Type, BooleanClass, IntClass, IntClass, IntClass, IntClass),
      TYPEVAR("ZR") := TYPE_TUPLE(IntClass, IntClass, TYPE_LIST(TYPE_REF("ZOT")), TYPE_LIST(TYPE_REF("ZOT")), TYPE_LIST(TYPE_REF("ZOR"))),
      TYPEVAR("ZRO") := TYPE_EITHER(TYPE_REF("ZR"), IntClass))

    BLOCK (
      List(
        IMPORT(s"$importsPackage._"),
        IMPORT(s"$importsPackage.zone._"),
        IMPORT("scala.collection.JavaConverters._"),
        IMPORT("scala.language.postfixOps"),
        OBJECTDEF("tzdb") := BLOCK(aliases ::: List(OBJECTDEF("rules") := rules.toTree, rows.flatMap(_.select[Zone]).toTree, rows.flatMap(_.select[Link]).toTree)))
    ) inPackage tzdbPackage withComment autoGeneratedCommend
  }

  def exportAll(dir: java.io.File, to: java.io.File, packageName: String, importsPackage: String)
    (implicit genParams: TreeGenerator[Map[Zone, ZoneRulesParams]], genZones: TreeGenerator[List[Zone]], genLinks: TreeGenerator[List[Link]]): IO[Unit] = {
    import better.files._
    for {
      rows      <- TZDBParser.parseAll(File(dir.toURI))
      //cleanrows <- IO(cleanLinks(rows))
      tree      <- IO(exportTzdb(packageName, importsPackage, rows))
      _         <- IO(File(to.toURI).write(treeToString(tree)))
    } yield ()
  }

  // Add to generated code. It isn't worth generating this with treehugger
  val paramsToRules = Nil
}
